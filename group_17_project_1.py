# -*- coding: utf-8 -*-
"""Group_17_project_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19V5DxVIrn-4hwsmnT96ap9XNqYZq_c6M
"""

class Array:
    '''This class defines a 2D Array with its linear algebra functions and statistics functions'''
    def __init__(self,nested_list):
        '''initiate the characteristics of the 2D array, including size, data, row, col and shape'''
        #Check if the input is a nested list
        try:
            self.size = len((nested_list))* len((nested_list[0]))
        except TypeError:
            raise TypeError('Please input a nested list to form a 2D array')
        #Check if the input nested list have same length for each row
        result = all(len(elems) == len((nested_list[0])) for elems in nested_list)
        if result :
            self.data = nested_list
            self.row = len(nested_list)
            self.col = len(nested_list[0])
            self.shape = (self.row,self.col)
        else:   
            raise TypeError('Each row of the 2D array should have the same size')

  
    def __str__(self):
        '''Make the array object print out as a nested list'''
        return str(self.data)

    def __add__(self,other):
        '''This defines the elementary wise addition of 2D array(self + other(scalar,nested list, or Array))'''
        if type(other) == int or type(other) == float:
            ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
            for i in range(self.row):
                for j in range(self.col):
                    ans.data[i][j] = self.data[i][j] + other
        else:
            if type(other) == list:
                other=Array(other)
            if self.shape == other.shape:
                ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
                for i in range(self.row):
                    for j in range(self.col):
                        ans.data[i][j] = self.data[i][j] + other.data[i][j]
            else:
                raise TypeError('Cannot add two Arrays of different shapes')
        return ans
    
    def __sub__(self,other):
        '''This defines the elementary wise substraction of 2D array(self - other(scalar,nested list, or Array))'''
        if type(other) == int or type(other) == float:
            ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
            for i in range(self.row):
                for j in range(self.col):
                    ans.data[i][j] = self.data[i][j] - other
        else:
            if type(other) == list:
                other=Array(other)
            if self.shape == other.shape:
                ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
                for i in range(self.row):
                    for j in range(self.col):
                        ans.data[i][j] = self.data[i][j] - other.data[i][j]
            else:
                raise TypeError('Cannot substract two Arrays of different shapes')
        return ans
    
    def __mul__(self,other):
        '''This defines the elementary wise multiplication of 2D array(self * other(scalar,nested list, or Array))'''
        if type(other) == int or type(other) == float:
            ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
            for i in range(self.row):
                for j in range(self.col):
                    ans.data[i][j] = self.data[i][j] * other
        else:
            if type(other) == list:
                other=Array(other)
            if self.shape == other.shape:
                ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
                for i in range(self.row):
                    for j in range(self.col):
                        ans.data[i][j] = self.data[i][j] * other.data[i][j]
            else:
                raise TypeError('Cannot multiply two Arrays of different shapes')
        return ans
    
    def __truediv__(self,other):
        '''This defines the elementary wise division of 2D array(self / other(scalar,nested list, or Array))'''
        if type(other) == int or type(other) == float:
            ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
            for i in range(self.row):
                for j in range(self.col):
                    ans.data[i][j] = self.data[i][j] / other
        else:
            if type(other) == list:
                other=Array(other)
            if self.shape == other.shape:
                ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
                for i in range(self.row):
                    for j in range(self.col):
                        ans.data[i][j] = self.data[i][j] / other.data[i][j]
            else:
                raise TypeError('Cannot divide two Arrays of different shapes')
        return ans

    def __radd__(self,other):
        '''Same as add, but This defines the elementary wise addition of other(scalar,nested list, or Array) + 2D array'''
        if type(other) == int or type(other) == float:
            ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
            for i in range(self.row):
                for j in range(self.col):
                    ans.data[i][j] = self.data[i][j] + other
        else:
            if type(other) == list:
                other=Array(other)
            if self.shape == other.shape:
                ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
                for i in range(self.row):
                    for j in range(self.col):
                        ans.data[i][j] = self.data[i][j] + other.data[i][j]
            else:
                raise TypeError('Cannot add two Arrays of different shapes')
        return ans
    
    def __rsub__(self,other):
        '''Same as sub, but This defines the elementary wise substraction of other(scalar,nested list, or Array) - 2D array'''
        if type(other) == int or type(other) == float:
            ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
            for i in range(self.row):
                for j in range(self.col):
                    ans.data[i][j] = other - self.data[i][j]
        else:
            if type(other) == list:
                other=Array(other)
            if self.shape == other.shape:
                ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
                for i in range(self.row):
                    for j in range(self.col):
                        ans.data[i][j] = other.data[i][j]-self.data[i][j] 
            else:
                raise TypeError('Cannot substract two Arrays of different shapes')
        return ans
    
    def __rmul__(self,other):
        '''Same as mul, but this defines the elementary wise addition of other(scalar,nested list, or Array) * 2D array'''
        if type(other) == int or type(other) == float:
            ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
            for i in range(self.row):
                for j in range(self.col):
                    ans.data[i][j] = self.data[i][j] * other
        else:
            if type(other) == list:
                other=Array(other)
            if self.shape == other.shape:
                ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
                for i in range(self.row):
                    for j in range(self.col):
                        ans.data[i][j] = self.data[i][j] * other.data[i][j]
            else:
                raise TypeError('Cannot multiply two Arrays of different shapes')
        return ans
    
    def __rtruediv__(self,other):
        '''Same as truediv, but this defines the elementary wise division of other(scalar,nested list, or Array) / 2D array'''
        if type(other) == int or type(other) == float:
            ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
            for i in range(self.row):
                for j in range(self.col):
                    ans.data[i][j] = other / self.data[i][j]
        else:
            if type(other) == list:
                other=Array(other)
            if self.shape == other.shape:
                ans = Array([[0 for j in range(self.col)] for i in range(self.row)])
                for i in range(self.row):
                    for j in range(self.col):
                        ans.data[i][j] = other.data[i][j] / self.data[i][j]
            else:
                raise TypeError('Cannot divide two Arrays of different shapes')
        return ans
  
    def __neg__(self):
        '''This function returns negation of the Array'''
        neg_mat= Array([[0 for j in range(self.col)] for i in range(self.row)])
        for i in range(self.row):
            for j in range(self.col):
                neg_mat.data[i][j]= -self.data[i][j]
        return neg_mat
        
  
    def __pow__(self,n):
        '''This defines the elementary wise power of the Array'''
        try:
            n=float(n)
        except ValueError:
            raise ValueError('Please input an integer or a float')
        pow_mat= Array([[0 for j in range(self.col)] for i in range(self.row)])
        for i in range(self.row):
            for j in range(self.col):
                pow_mat.data[i][j]=self.data[i][j]**n
        return pow_mat
        
  
    def __getitem__(self,key):
        '''This function defines how to get items from the array, the input can wither be an integer or a tuple'''
        if type(key) == tuple:
            return self.data[key[0]][key[1]]
        elif type(key) == int:
            return self.data[key]
        else:
            raise ValueError('Please input an integer or a tuple')
      
    def dot(self,other):
        '''This function computes the dot product between two Arrays'''
        if type(other) == list:
            other=Array(other)
        if self.col == other.row: 
            ans = Array([[0 for j in range(other.col)] for i in range(self.row)])
            for i in range(ans.row):
                for j in range(ans.col):
                    sum = 0
                    for k in range(self.col):
                        sum += self.data[i][k] * other[k][j]
                        ans.data[i][j] = sum
        else:
            raise RuntimeError('Cannot do dot product on given inputs')
        return ans
  
    def sums(self,axis=2):
        '''This function computes sum of the arrays over one axis, default is acrooss the wholw array'''
        vector = []
        a = 0
        if axis == 0:
            l = []
            for j in range(self.col):
                for i in range(self.row):
                    a += self.data[i][j]
                l.append(a)
                a = 0
            vector.append(l)
            return Array(vector)
        elif axis == 1:
            for i in range(self.row):
                for j in range(self.col):
                    a += self.data[i][j]
                vector.append([a]) 
                a = 0
            return Array(vector)
        elif axis == 2:
            for i in range(self.row):
                for j in range(self.col):
                    a += self.data[i][j]
            return a
    

    def mean(self,axis=2):
        '''This function computes mean of the arrays over one axis, default is acrooss the wholw array'''
        sum_of_elements = self.sums(axis)
        if axis == 0:
            return sum_of_elements/self.row
        elif axis == 1:
            return sum_of_elements/self.col
        elif axis == 2:
            return sum_of_elements/self.size
  

    def transpose(self):
        '''This function transposes the 2D Array, the shape (i,j) will change to (j,i)'''
        transpose_matrix = [[0 for i in range(self.row)] for i in range(self.col)]
        for i in range(self.row):
            for j in range(self.col):
                transpose_matrix[j][i] = self.data[i][j]
        return Array(transpose_matrix)

    def var(self):
        '''This function computes a covariance matrix that basically eaquls to np.cov(Array.T)'''
        xbar=self.mean(0)
        XC=[[0 for j in range(self.col)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.col):
                XC[i][j]=self.data[i][j]-xbar[0][j]
        XC=Array(XC)
        XCT= XC.transpose()
        C= (XCT/(self.row-1)).dot(XC)
        return C

# TEST ADD / SUB / MUL / TRUEDIV
# 1. Array(a) + Array(b)
a = Array([[1,2],[3,4]])
b = Array([[4,5],[6,7]])
c = a+b
print("1. Array", a, "+", "Array", b, "=", c)
# 2. Array(a) + nested_list
a = Array([[1,2],[3,4]])
b = [[4,5],[6,7]]
c = a+b
print("2. Array", a, "+", "Nested list", b, "=", c)
# 3. Array(a).__add__(nested_list)
a = Array([[1,2],[3,4]])
b = [[4,5],[6,7]]
c = a.__add__(b)
print("3. Array", a, ".__add__(", b, ") =", c)
# 4. Array(a) + scalar
a = Array([[1,2],[3,4]])
b = 5.5
c = a+b
print("4. Array", a, "+", "Scalar", b, "=", c)
# 5. Array(a).__add__(scalar)
a = Array([[1,2],[3,4]])
b = 5
c = a.__add__(b)
print("5. Array", a, ".__add__(", b, ") =", c)

# TEST FOR DOT
a = Array([[1,2,3], [4,5,6]])
b = [[1,2,3],[3,4,5],[5,6,7]]
c = a.dot(b)
print("Array", a, ".dot(", b, ") =", c)

import numpy as np

#Example and notes
a=Array([[1,2,3],[4,5,6]])
print(a.sums(0))
print(a.sums(1))
print(a.sums())
#a.sum(axis=0)=[[5,7,9]]
#a.sum(axis=1)=[[6],[15]]
print(a.mean())
print(a.mean(0))
print(a.mean(1))

#For the statistics methods, make sure to call the linear algebra methods we created.

# make sure np.cov has the same results as our cov
#Use n-1 not n in calculation for var

X=np.array([[1,2,3],[4,5,6]])
print(np.cov(X.T))
print(a.var())
print(a)

print(a)
print(-a)
print(a)
print(a**3.5)
print(a)

print(a.__neg__())